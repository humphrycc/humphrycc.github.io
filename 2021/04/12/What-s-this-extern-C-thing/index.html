<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>What&#39;s this extern &#34;C&#34; thing? | HUCHI</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="What’s this extern “C” thing?  Most C++ compilers do something called name decoration, or name mangling. In short, in order to support C++ function overloading, and C++ type-safe linkage, most C++ co">
<meta property="og:type" content="article">
<meta property="og:title" content="What&#39;s this extern &quot;C&quot; thing?">
<meta property="og:url" content="https://humphrycc.github.io/2021/04/12/What-s-this-extern-C-thing/index.html">
<meta property="og:site_name" content="HUCHI">
<meta property="og:description" content="What’s this extern “C” thing?  Most C++ compilers do something called name decoration, or name mangling. In short, in order to support C++ function overloading, and C++ type-safe linkage, most C++ co">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-04-12T13:14:16.000Z">
<meta property="article:modified_time" content="2021-04-19T03:48:40.326Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="c++">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="HUCHI" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">HUCHI</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://humphrycc.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-What-s-this-extern-C-thing" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/12/What-s-this-extern-C-thing/" class="article-date">
  <time class="dt-published" datetime="2021-04-12T13:14:16.000Z" itemprop="datePublished">2021-04-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      What&#39;s this extern &#34;C&#34; thing?
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p><a target="_blank" rel="noopener" href="https://web.archive.org/web/20181115023158/http://www.comeaucomputing.com/techtalk/#externc">What’s this extern “C” thing?</a></p>
</blockquote>
<p>Most C++ compilers do something called <em>name decoration</em>, or <em>name mangling</em>. In short, in order to support C++ function overloading, and C++ type-safe linkage, most C++ compilers will tack on some type encoding information onto the end of some of your identifiers. For instance, when Comeau C++ see this prototype</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">double</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>it internally changes the name to <code>foo__Fid</code>, where the <code>F</code> indicates that it is a function, the <code>i</code> indicates the first argument is an <code>int</code> and the <code>d</code> indicates that the second argument is a <code>double</code>. Other compilers do this in a similar manner. Since the definition of this function will be similarly decorated, the linker will resolve this symbol fine.</p>
<p>Now, consider something such as <code>printf</code> which is normally prototyped as follows:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *, ...)</span></span>;</span><br></pre></td></tr></table></figure>

<p>which hence might map into <code>printf__FPCce</code>. However, if <code>printf</code> was compiled with a C compiler, well, no C compiler that we know of does name decorating (although they could, they don’t), therefore, the name will not be resolved by the linker. To get around this, in most cases, you should use a linkage specification. Here’s the above example again:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">double</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>Now most implementations will not decorate <code>foo</code> any longer. Of course, you would <code>extern &quot;C&quot;</code> the function definition too (since the definition file should also be <code>#include</code>ing the header file which contains the prototype, that will be satisfactory as far as the compiler is concerned, though you should consider self-documenting code). As well, if you have many such functions, you can create linkage blocks, consider:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stdio.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *, ...)</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Here, most C++ compilers will not decorate <code>printf</code>‘s name, therefore, it will probably now link with the binary version that was compiled by the C compiler. It’s often useful to create a “co-ed” header file, so in such cases, this coding technique might be helpful:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stdio.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// stuff from before</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>Since Standard C is not required to define <code>__cplusplus</code>, then, when compiling with a C compiler, the extern block won’t be established (but of course all the prototypes and such will be, which is as the C compiler would expect it).</p>
<p>Please note that name decoration is not required by C++, it is strictly an implementation detail. However, all C++ compilers do it. Similarly, a linkage specification should be considered a fighting chance at cross language linkage and not a guarantee. Again though, for most platforms, the reality is that it will work fine.</p>
<p>Too, do note that a linkage specification does not bring you into the other language! That is, you are still writing C++ code. As such, note that C++ keywords are still in existance even within a linkage specification – so for instance, using <code>new</code> or <code>bool</code> or <code>private</code> as identifier names will end up being kicked out as errors; obviously then you’ll need to rename those identifiers (you could do some preprocessor gymanstics but in the long run doing so usually does not pan out). Also note that doing something like passing a class based object, a reference, etc., to a C function means you are on your own. Note that other things effect name decoration too, such as a <code>class</code> name, <code>namespace</code>, etc. As well, you won’t be overloading a function which you’ve <code>extern &quot;C&quot;</code>d because then you would have two functions with the same name (since most implementation wouldn’t mangle them).</p>
<p>Also, doing this is usually a mistake:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123; <span class="comment">// wrapped around #include, but prefer within header</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;SomeHeaderFile.h&quot;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>because if the header is not prepared for being <code>extern &quot;C&quot;</code>d then doing the above is most likely just going to result in a bunch of error messages, and probably cryptically so too. Chances are good that the header will drag in other headers and bad fun will just ensue from there with nested headers, typedefs and who knows what else. Your <code>extern &quot;C&quot;</code>ing should follow the Las Vegas tenet <em>What happens in extern “C” stays in extern “C”</em> and <strong>keep your <code>extern &quot;C&quot;</code> blocks within files not across them</strong>.</p>
<p>The above has so far considered only the scenario of calling a C function from C++. The contrary, calling a C++ function from a C function, has the same solution. In other words, if you <code>extern &quot;C&quot;</code> a C++ function, then most implementations won’t mangle it, therefore, most C compilers will be able to link with it. However, as just mentioned, if the C++ function expects something such as a reference argument, you are usually of course on your own. There’s other issues too in this direction, for instance, consideration of C++’s overloading, the function expecting a C++ class based object as a parameter, etc. If it’s not clear, C does not have all the features available in C++, and trying to mimic them (the calling routine(s) from C will have to do this) can be challenging to say the least in some cases. This all tends to complete with calling a C++ function from C, even with <code>extern &quot;C&quot;</code>. In some cases, it may be worth considering stubs routines to try and ease the pain, but this should be decided carefully. Of course as well, a C++ application can use C++ functions which have been <code>extern &quot;C&quot;</code>d.</p>
<p>There are other aspect to linkage specifications that you might want to be aware of. For instance, it can be applied to objects. With the above under your belt, you may now want to pursue a quality C++ text book on this matter.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://humphrycc.github.io/2021/04/12/What-s-this-extern-C-thing/" data-id="ckno26i440001ceophattd6m2" data-title="What&#39;s this extern &#34;C&#34; thing?" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/" rel="tag">c++</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/04/19/What-is-the-difference-between-a-concrete-class-and-an-abstract-class/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          What is the difference between a concrete class and an abstract class?
        
      </div>
    </a>
  
  
    <a href="/2021/04/12/Why-is-an-unnamed-namespace-used-instead-of-static/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Why is an unnamed namespace used instead of static?</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/c/" rel="tag">c++</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/c/" style="font-size: 10px;">c++</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/04/19/What-is-the-difference-between-a-concrete-class-and-an-abstract-class/">What is the difference between a concrete class and an abstract class?</a>
          </li>
        
          <li>
            <a href="/2021/04/12/What-s-this-extern-C-thing/">What&#39;s this extern &#34;C&#34; thing?</a>
          </li>
        
          <li>
            <a href="/2021/04/12/Why-is-an-unnamed-namespace-used-instead-of-static/">Why is an unnamed namespace used instead of static?</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>