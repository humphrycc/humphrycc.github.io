<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Do we need User-defined literal? | HUCHI</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;238057&#x2F;6799372  At first sight, it seems to be simple syntactic sugar. But when looking deeper, we see it’s more than syntactic sugar, as it extends the C++ user’s options">
<meta property="og:type" content="article">
<meta property="og:title" content="Do we need User-defined literal?">
<meta property="og:url" content="https://humphrycc.github.io/2021/04/27/Do-we-need-User-defined-literal/index.html">
<meta property="og:site_name" content="HUCHI">
<meta property="og:description" content="https:&#x2F;&#x2F;stackoverflow.com&#x2F;a&#x2F;238057&#x2F;6799372  At first sight, it seems to be simple syntactic sugar. But when looking deeper, we see it’s more than syntactic sugar, as it extends the C++ user’s options">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-04-27T13:22:52.000Z">
<meta property="article:modified_time" content="2021-04-27T05:45:50.065Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="c++">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="HUCHI" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">HUCHI</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://humphrycc.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Do-we-need-User-defined-literal" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/27/Do-we-need-User-defined-literal/" class="article-date">
  <time class="dt-published" datetime="2021-04-27T13:22:52.000Z" itemprop="datePublished">2021-04-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Do we need User-defined literal?
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/a/238057/6799372">https://stackoverflow.com/a/238057/6799372</a></p>
</blockquote>
<p>At first sight, it seems to be simple syntactic sugar.</p>
<p>But when looking deeper, we see it’s more than syntactic sugar, as <strong>it extends the C++ user’s options to create user-defined types that behave exactly like distinct built-in types</strong>. In this, this little “bonus” is a very interesting C++11 addition to C++.</p>
<h1 id="Do-we-really-need-it-in-C"><a href="#Do-we-really-need-it-in-C" class="headerlink" title="Do we really need it in C++?"></a>Do we really need it in C++?</h1><p>I see few uses in the code I wrote in the past years, but just because I didn’t use it in C++ doesn’t mean it’s not interesting for <em>another C++ developer</em>.</p>
<p>We had used in C++ (and in C, I guess), compiler-defined literals, to type integer numbers as <code>short</code> or <code>long</code> integers, real numbers as <code>float</code> or <code>double</code> (or even <code>long double</code>), and character strings as normal or wide chars.</p>
<p><strong>In C++, we had the possibility to create our own types (i.e. classes), with potentially no overhead (inlining, etc.).</strong> We had the possibility to add operators to their types, to have them behave like similar built-in types, which enables C++ developers to use matrices and complex numbers as naturally as they would have if these have been added to the language itself. We can even add cast operators (which is usually a bad idea, but sometimes, it’s just the right solution).</p>
<p><strong>We still missed one thing to have user-types behave as built-in types: user-defined literals.</strong></p>
<p>So, I guess it’s a natural evolution for the language, but to be as complete as possible: “<em>If you want to create a type, and you want it to behave as much possible as a built-in types, here are the tools…</em>“</p>
<p>I’d guess it’s very similar to .NET’s decision to make every primitive a struct, including booleans, integers, etc., and have all structs derive from Object. This decision alone puts .NET far beyond Java’s reach when working with primitives, no matter how much boxing/unboxing hacks Java will add to its specification.</p>
<h1 id="Do-YOU-really-need-it-in-C"><a href="#Do-YOU-really-need-it-in-C" class="headerlink" title="Do YOU really need it in C++?"></a>Do YOU really need it in C++?</h1><p>This question is for <strong>YOU</strong> to answer. Not Bjarne Stroustrup. Not Herb Sutter. Not whatever member of C++ standard committee. This is why you have the choice in C++, and they won’t restrict a useful notation to built-in types alone.</p>
<p>If you need it, then it is a welcome addition. If you don’t, well… Don’t use it. It will cost you nothing.</p>
<p>Welcome to C++, the language where features are optional.</p>
<h2 id="Bloated-Show-me-your-complexes"><a href="#Bloated-Show-me-your-complexes" class="headerlink" title="Bloated??? Show me your complexes!!!"></a>Bloated??? Show me your complexes!!!</h2><p>There is a difference between bloated and complex (pun intended).</p>
<p>Like shown by Niels at <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/237804/what-new-capabilities-do-user-defined-literals-add-to-c#237821">What new capabilities do user-defined literals add to C++?</a>, being able to write a complex number is one of the two features added “recently” to C and C++:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C89:</span></span><br><span class="line">MyComplex z1 = &#123; <span class="number">1</span>, <span class="number">2</span> &#125; ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C99: You&#x27;ll note I is a macro, which can lead</span></span><br><span class="line"><span class="comment">// to very interesting situations...</span></span><br><span class="line"><span class="keyword">double</span> complex z1 = <span class="number">1</span> + <span class="number">2</span>*I;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++:</span></span><br><span class="line"><span class="function">std::complex&lt;<span class="keyword">double</span>&gt; <span class="title">z1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span> </span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++11: You&#x27;ll note that &quot;i&quot; won&#x27;t ever bother</span></span><br><span class="line"><span class="comment">// you elsewhere</span></span><br><span class="line">std::complex&lt;<span class="keyword">double</span>&gt; z1 = <span class="number">1</span> + <span class="number">2</span>_i ;</span><br></pre></td></tr></table></figure>

<p>Now, both C99 <code>double complex</code> type and C++ <code>std::complex</code> type are able to be multiplied, added, subtracted, etc., using operator overloading.</p>
<p>But in C99, they just added another type as a built-in type, and built-in operator overloading support. And they added another built-in literal feature.</p>
<p>In C++, they just used existing features of the language, saw that the literal feature was a natural evolution of the language, and thus added it.</p>
<p>In C, if you need the same notation enhancement for another type, you’re out of luck until your lobbying to add your quantum wave functions (or 3D points, or whatever basic type you’re using in your field of work) to the C standard as a built-in type succeeds.</p>
<p>In C++11, you just can do it yourself:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point p = <span class="number">25</span>_x + <span class="number">13</span>_y + <span class="number">3</span>_z ; <span class="comment">// 3D point</span></span><br></pre></td></tr></table></figure>

<p><strong>Is it bloated? No</strong>, the need is there, as shown by how both C and C++ complexes need a way to represent their literal complex values.</p>
<p><strong>Is it wrongly designed? No</strong>, it’s designed as every other C++ feature, with extensibility in mind.</p>
<p><strong>Is it for notation purposes only? No</strong>, as it can even add type safety to your code.</p>
<p>For example, let’s imagine a CSS oriented code:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">css::Font::Size p0 = <span class="number">12</span>_pt ;       <span class="comment">// Ok</span></span><br><span class="line">css::Font::Size p1 = <span class="number">50</span>_percent ;  <span class="comment">// Ok</span></span><br><span class="line">css::Font::Size p2 = <span class="number">15</span>_px ;       <span class="comment">// Ok</span></span><br><span class="line">css::Font::Size p3 = <span class="number">10</span>_em ;       <span class="comment">// Ok</span></span><br><span class="line">css::Font::Size p4 = <span class="number">15</span> ;          <span class="comment">// ERROR : Won&#x27;t compile !</span></span><br></pre></td></tr></table></figure>

<p>It is then very easy to enforce a strong typing to the assignment of values.</p>
<h2 id="Is-is-dangerous"><a href="#Is-is-dangerous" class="headerlink" title="Is is dangerous?"></a>Is is dangerous?</h2><p>Good question. Can these functions be namespaced? If yes, then Jackpot!</p>
<p>Anyway, <strong>like everything, you can kill yourself if a tool is used improperly</strong>. C is powerful, and you can shoot your head off if you misuse the C gun. C++ has the C gun, but also the scalpel, the taser, and whatever other tool you’ll find in the toolkit. You can misuse the scalpel and bleed yourself to death. Or you can build very elegant and robust code.</p>
<p>So, like every C++ feature, do you really need it? It is the question you must answer before using it in C++. If you don’t, it will cost you nothing. But if you do really need it, at least, the language won’t let you down.</p>
<h2 id="The-date-example"><a href="#The-date-example" class="headerlink" title="The date example?"></a>The date example?</h2><p>Your error, it seems to me, is that you are mixing operators:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1974</span>/<span class="number">01</span>/<span class="number">06</span>AD</span><br><span class="line">    ^  ^  ^</span><br></pre></td></tr></table></figure>

<p>This can’t be avoided, because <code>/</code> being an operator, the compiler must interpret it. And, AFAIK, it is a good thing.</p>
<p>To find a solution for your problem, I would write the literal in some other way. For example:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;1974-01-06&quot;</span>_AD ;   <span class="comment">// ISO-like notation</span></span><br><span class="line"><span class="string">&quot;06/01/1974&quot;</span>_AD ;   <span class="comment">// french-date-like notation</span></span><br><span class="line"><span class="string">&quot;jan 06 1974&quot;</span>_AD ;  <span class="comment">// US-date-like notation</span></span><br><span class="line"><span class="number">19740106</span>_AD ;       <span class="comment">// integer-date-like notation</span></span><br></pre></td></tr></table></figure>

<p>Personally, I would choose the integer and the ISO dates, but it depends on YOUR needs. Which is the whole point of letting the user define its own literal names.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://humphrycc.github.io/2021/04/27/Do-we-need-User-defined-literal/" data-id="cknzlw0l00001gsose3cz9ir2" data-title="Do we need User-defined literal?" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/" rel="tag">c++</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2021/04/19/Virtuality/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Virtuality</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/c/" rel="tag">c++</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/c/" style="font-size: 10px;">c++</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/04/27/Do-we-need-User-defined-literal/">Do we need User-defined literal?</a>
          </li>
        
          <li>
            <a href="/2021/04/19/Virtuality/">Virtuality</a>
          </li>
        
          <li>
            <a href="/2021/04/19/When-to-use-virtual-destructors/">When to use virtual destructors?</a>
          </li>
        
          <li>
            <a href="/2021/04/19/What-is-the-use-of-having-destructor-as-private/">What is the use of having destructor as private?</a>
          </li>
        
          <li>
            <a href="/2021/04/19/What-uses-are-there-for-placement-new/">What uses are there for &#34;placement new&#34;?</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>