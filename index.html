<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>HUCHI</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="HUCHI">
<meta property="og:url" content="https://humphrycc.github.io/index.html">
<meta property="og:site_name" content="HUCHI">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="HUCHI" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">HUCHI</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://humphrycc.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-What-is-the-difference-between-a-concrete-class-and-an-abstract-class" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/19/What-is-the-difference-between-a-concrete-class-and-an-abstract-class/" class="article-date">
  <time class="dt-published" datetime="2021-04-19T11:28:51.000Z" itemprop="datePublished">2021-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/19/What-is-the-difference-between-a-concrete-class-and-an-abstract-class/">What is the difference between a concrete class and an abstract class?</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/2149207/what-is-the-difference-between-a-concrete-class-and-an-abstract-class">https://stackoverflow.com/questions/2149207/what-is-the-difference-between-a-concrete-class-and-an-abstract-class</a></p>
</blockquote>
<blockquote>
<p>I am learning C++, but I am confused about abstract class and concrete class. Some real world examples would be appreciated.<br>what is the difference between normal derived class and concrete class?</p>
</blockquote>
<p>An <strong>abstract class</strong> is a class for which one or more methods are declared but not defined, meaning that the compiler knows <em>these methods are part of the class, but not what code to execute for that method</em>. These are called abstract methods. Here is an example of an abstract class.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">shape</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>This declares an abstract class which specifies that any descendants of the class should implement the <code>draw</code> method if the class is to be <strong>concrete</strong>. You cannot instantiate this class because it is abstract, after all, the compiler wouldn’t know what code to execute if you called member <code>draw</code>. So you can not do the following:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shape <span class="title">my_shape</span><span class="params">()</span></span>;</span><br><span class="line">my_shape.<span class="built_in">draw</span>();</span><br></pre></td></tr></table></figure>

<p>To be able to actually use the draw method you would need to <em>derive</em> classes from this abstract class, which do implement the <code>draw</code> method, making the classes concrete:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">circle</span> :</span> <span class="keyword">public</span> shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">circle</span>(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> radius) &#123;</span><br><span class="line">    <span class="comment">/* set up the circle */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* do stuff to draw the circle */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">rectangle</span> :</span> <span class="keyword">public</span> shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">rectangle</span>(<span class="keyword">int</span> min_x, <span class="keyword">int</span> min_y, <span class="keyword">int</span> max_x, <span class="keyword">int</span> max_y) &#123;</span><br><span class="line">    <span class="comment">/* set up rectangle */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* do stuff to draw the rectangle */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Now you can instantiate the concrete objects <code>circle</code> and <code>rectangle</code> and use their <code>draw</code> methods:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">circle <span class="title">my_circle</span><span class="params">(<span class="number">40</span>, <span class="number">30</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">rectangle <span class="title">my_rectangle</span><span class="params">(<span class="number">20</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">15</span>)</span></span>;</span><br><span class="line">my_circle.<span class="built_in">draw</span>();</span><br><span class="line">my_rectangle.<span class="built_in">draw</span>();</span><br></pre></td></tr></table></figure>

<p>Now of course the question is, why would you want to do this? Couldn’t you just as well have defined the <code>circle</code> and <code>rectangle</code> classes and have done away with the whole shape class? You could, but then you wouldn’t be able to take advantage of their inheritance:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;shape*&gt; my_scene;</span><br><span class="line">my_scene.push_back(new circle(40, 30, 10));</span><br><span class="line">my_scene.push_back(new rectangle(20, 10, 50, 15));</span><br><span class="line">std::for_each(my_scene.begin(), my_scene.end(), std::mem_fun_ref(&amp;shape::draw)</span><br></pre></td></tr></table></figure>

<p>This code let’s you collect all your shapes into one container. This makes it a lot easier if you have a lot of shapes and many different shapes in your scene. For example we can now draw all the shapes in one go, and the code that does so doesn’t even need to know about the different types of shapes we have.</p>
<p>Now finally we need to know why the <code>draw</code> function of <code>shape</code> is abstract, and not just an empty function, i.e. why didn’t we just define:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">shape</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* do nothing */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>The reason for this is that we don’t really want objects of type <code>shape</code>, they wouldn’t be real things anyway, they would be abstract. So it doesn’t make any sense to define an implementation for the <code>draw</code> method, even an empty one. Making the <code>shape</code> class abstract prevents us from mistakenly instantiating the <code>shape</code> class, or mistakenly calling the empty <code>draw</code> function of the base class instead of the <code>draw</code> function of the derived classes. In effect we define an interface for any class that would like to behave like a shape, we say that any such class should have a <code>draw</code> method that looks like we have specified it should.</p>
<p>To answer you last question, there isn’t any such thing as a ‘normal derived class’ <em>every class is either abstract or concrete</em>. A class that has any abstract methods is abstract, any class that doesn’t is concrete. It’s just a way to differentiate the two types of classes. A base class can be either abstract or concrete and a derived class can be either abstract or concrete:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">abstract_base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">abstract_method1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">abstract_method2</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">concrete_base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">concrete_method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* do something */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">abstract_derived1</span> :</span> <span class="keyword">public</span> abstract_base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">abstract_method3</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">abstract_derived2</span> :</span> <span class="keyword">public</span> concrete_base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">abstract_method3</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">abstract_derived3</span> :</span> <span class="keyword">public</span> abstract_base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="title">abstract_method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* do something */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* note that we do not provide an implementation for</span></span><br><span class="line"><span class="comment">     abstract_method2 so the class is still abstract */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">concrete_derived1</span> :</span> <span class="keyword">public</span> concrete_base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">concrete_method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* do something */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">concrete_derived2</span> :</span> <span class="keyword">public</span> abstract_base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">abstract_method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* do something */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">abstract_method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* do something */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* This class is now concrete because no abstract methods remain */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://humphrycc.github.io/2021/04/19/What-is-the-difference-between-a-concrete-class-and-an-abstract-class/" data-id="ckno26i3z0000ceop7ss9cpn6" data-title="What is the difference between a concrete class and an abstract class?" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/" rel="tag">c++</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-What-s-this-extern-C-thing" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/12/What-s-this-extern-C-thing/" class="article-date">
  <time class="dt-published" datetime="2021-04-12T13:14:16.000Z" itemprop="datePublished">2021-04-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/12/What-s-this-extern-C-thing/">What&#39;s this extern &#34;C&#34; thing?</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p><a target="_blank" rel="noopener" href="https://web.archive.org/web/20181115023158/http://www.comeaucomputing.com/techtalk/#externc">What’s this extern “C” thing?</a></p>
</blockquote>
<p>Most C++ compilers do something called <em>name decoration</em>, or <em>name mangling</em>. In short, in order to support C++ function overloading, and C++ type-safe linkage, most C++ compilers will tack on some type encoding information onto the end of some of your identifiers. For instance, when Comeau C++ see this prototype</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">double</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>it internally changes the name to <code>foo__Fid</code>, where the <code>F</code> indicates that it is a function, the <code>i</code> indicates the first argument is an <code>int</code> and the <code>d</code> indicates that the second argument is a <code>double</code>. Other compilers do this in a similar manner. Since the definition of this function will be similarly decorated, the linker will resolve this symbol fine.</p>
<p>Now, consider something such as <code>printf</code> which is normally prototyped as follows:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *, ...)</span></span>;</span><br></pre></td></tr></table></figure>

<p>which hence might map into <code>printf__FPCce</code>. However, if <code>printf</code> was compiled with a C compiler, well, no C compiler that we know of does name decorating (although they could, they don’t), therefore, the name will not be resolved by the linker. To get around this, in most cases, you should use a linkage specification. Here’s the above example again:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">double</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>Now most implementations will not decorate <code>foo</code> any longer. Of course, you would <code>extern &quot;C&quot;</code> the function definition too (since the definition file should also be <code>#include</code>ing the header file which contains the prototype, that will be satisfactory as far as the compiler is concerned, though you should consider self-documenting code). As well, if you have many such functions, you can create linkage blocks, consider:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stdio.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *, ...)</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Here, most C++ compilers will not decorate <code>printf</code>‘s name, therefore, it will probably now link with the binary version that was compiled by the C compiler. It’s often useful to create a “co-ed” header file, so in such cases, this coding technique might be helpful:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stdio.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// stuff from before</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>Since Standard C is not required to define <code>__cplusplus</code>, then, when compiling with a C compiler, the extern block won’t be established (but of course all the prototypes and such will be, which is as the C compiler would expect it).</p>
<p>Please note that name decoration is not required by C++, it is strictly an implementation detail. However, all C++ compilers do it. Similarly, a linkage specification should be considered a fighting chance at cross language linkage and not a guarantee. Again though, for most platforms, the reality is that it will work fine.</p>
<p>Too, do note that a linkage specification does not bring you into the other language! That is, you are still writing C++ code. As such, note that C++ keywords are still in existance even within a linkage specification – so for instance, using <code>new</code> or <code>bool</code> or <code>private</code> as identifier names will end up being kicked out as errors; obviously then you’ll need to rename those identifiers (you could do some preprocessor gymanstics but in the long run doing so usually does not pan out). Also note that doing something like passing a class based object, a reference, etc., to a C function means you are on your own. Note that other things effect name decoration too, such as a <code>class</code> name, <code>namespace</code>, etc. As well, you won’t be overloading a function which you’ve <code>extern &quot;C&quot;</code>d because then you would have two functions with the same name (since most implementation wouldn’t mangle them).</p>
<p>Also, doing this is usually a mistake:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123; <span class="comment">// wrapped around #include, but prefer within header</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;SomeHeaderFile.h&quot;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>because if the header is not prepared for being <code>extern &quot;C&quot;</code>d then doing the above is most likely just going to result in a bunch of error messages, and probably cryptically so too. Chances are good that the header will drag in other headers and bad fun will just ensue from there with nested headers, typedefs and who knows what else. Your <code>extern &quot;C&quot;</code>ing should follow the Las Vegas tenet <em>What happens in extern “C” stays in extern “C”</em> and <strong>keep your <code>extern &quot;C&quot;</code> blocks within files not across them</strong>.</p>
<p>The above has so far considered only the scenario of calling a C function from C++. The contrary, calling a C++ function from a C function, has the same solution. In other words, if you <code>extern &quot;C&quot;</code> a C++ function, then most implementations won’t mangle it, therefore, most C compilers will be able to link with it. However, as just mentioned, if the C++ function expects something such as a reference argument, you are usually of course on your own. There’s other issues too in this direction, for instance, consideration of C++’s overloading, the function expecting a C++ class based object as a parameter, etc. If it’s not clear, C does not have all the features available in C++, and trying to mimic them (the calling routine(s) from C will have to do this) can be challenging to say the least in some cases. This all tends to complete with calling a C++ function from C, even with <code>extern &quot;C&quot;</code>. In some cases, it may be worth considering stubs routines to try and ease the pain, but this should be decided carefully. Of course as well, a C++ application can use C++ functions which have been <code>extern &quot;C&quot;</code>d.</p>
<p>There are other aspect to linkage specifications that you might want to be aware of. For instance, it can be applied to objects. With the above under your belt, you may now want to pursue a quality C++ text book on this matter.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://humphrycc.github.io/2021/04/12/What-s-this-extern-C-thing/" data-id="ckno26i440001ceophattd6m2" data-title="What&#39;s this extern &#34;C&#34; thing?" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/" rel="tag">c++</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Why-is-an-unnamed-namespace-used-instead-of-static" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/12/Why-is-an-unnamed-namespace-used-instead-of-static/" class="article-date">
  <time class="dt-published" datetime="2021-04-12T10:43:45.000Z" itemprop="datePublished">2021-04-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/12/Why-is-an-unnamed-namespace-used-instead-of-static/">Why is an unnamed namespace used instead of static?</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p><a target="_blank" rel="noopener" href="https://web.archive.org/web/20181115023158/http://www.comeaucomputing.com/techtalk/#nostatic">Why is an unnamed namespace used instead of static?</a></p>
</blockquote>
<p>in C++, some uses of the <code>static</code> keyword have been <strong>deprecated</strong>. In particular, an unnamed namespace should be favored over some previous uses of “file scope static’s”. In fact in some cases an unnamed namespace must be used in order to obtain a similar effect. That is to say, this code:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// x.cpp</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span> flag = <span class="literal">false</span>; <span class="comment">// AAA</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; <span class="keyword">if</span> (flag)... &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123; ...flag = <span class="literal">true</span>... &#125;</span><br></pre></td></tr></table></figure>

<p>should instead often be composed this way in C++:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// x.cpp</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="comment">/* NOTHING HERE!! */</span> &#123; <span class="comment">// BBB</span></span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>; <span class="comment">// no need for static here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The use of static in <code>AAA</code> indicates that flag has internal linkage. This means that flag is local to its translation unit (that is, effectively it is only known by its name in some source file, in this case <code>x.cpp</code>). This means that flag can’t be used by another translation unit (by its name at least). The goal is to have less global/cross-file name pollution in your programs while at the same time achieving some level of encapsulation. Such a goal is usually considered admirable and so therefore is often considered desirable (note that the goal, not the code, is being discussed in this sentence).</p>
<p>Contrast this to <code>BBB</code>. In the case of using the unnamed namespace above, flag has external linkage, yet it is effectively local to the translation unit. It is effectively still local because although we did not give the namespace a name, the compiler generated a unique name for it. In effect, the compiler changes <code>BBB</code> into this:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Just get UNIQUE established</span></span><br><span class="line"><span class="keyword">namespace</span> UNIQUE &#123; &#125; <span class="comment">// CCC</span></span><br><span class="line"><span class="comment">// Bring UNIQUE into this translation unit</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> UNIQUE;</span><br><span class="line"><span class="comment">// Now define UNIQUEs members</span></span><br><span class="line"><span class="keyword">namespace</span> UNIQUE &#123;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>; <span class="comment">// As Before</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>For each translation unit, a uniquely generated identifier name for <code>UNIQUE</code> somehow gets synthesized by the compiler, with the effect that no other translation unit can see names from an unnamed namespace, hence making it local even though the name may have external linkage.</p>
<p>Therefore, although flag in <code>CCC</code> has external linkage, its real name is <code>UNIQUE::flag</code>, but since <code>UNIQUE</code> is only known to <code>x.cpp</code>, it’s effectively local to <code>x.cpp</code> and is therefore not known to any other translation unit.</p>
<p>Ok, so far, most of the discussion has been about how the two provide local names, but what are the differences? And why was static deprecated and the unnamed namespace considered superior?</p>
<p>First, if nothing else, static means many different things in C++ and reducing one such use is considered a step in the right direction by some people. Second to consider is that names in unnamed namespaces may have external linkage whereas with static a name must have internal linkage. In other words, although there is a syntactic transformation shown above between <code>AAA</code> and <code>BBB</code>, the two are not exactly equal (the one between <code>BBB</code> and <code>CCC</code> is equal).</p>
<p>Most books and usenet posts usually leave you off about right here. No problem with that per se, as the above info is not to be tossed out the window. However, you can’t help but keep wondering what the <strong>BIG</strong> deal some people make about unnamed namespaces are. Some folks might even argue that they make your code less readable.</p>
<p>What’s significant though is that <strong>some template arguments cannot be names with internal linkage</strong>, instead some require names with external linkage. Remember, the types of the arguments to templates become part of the instantiation type, but names with internal linkage aren’t available to other translation units. A good rule of thumb to consider (said rather loosely) is that external names shouldn’t depend upon names with less linkage (definitely not of those with no linkage, and often not even w ith names of internal linkage). And so it follows from the above that instantiating such a template with a static such as from AAA just isn’t going to work. This is all similar to why these won’t work:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">const</span> <span class="keyword">int</span>&amp; T&gt; <span class="class"><span class="keyword">struct</span> <span class="title">xyz</span> &#123;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c = <span class="number">1</span>;</span><br><span class="line">xyz&lt;c&gt; y; <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> sc = <span class="number">1</span>; <span class="comment">// This is the kicker-out&#x27;er above</span></span><br><span class="line">xyz&lt;sc&gt; y2; <span class="comment">// not ok</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">char</span> *p&gt; <span class="class"><span class="keyword">struct</span> <span class="title">abc</span> &#123;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> comeau[] = <span class="string">&quot;Comeau C++&quot;</span>;</span><br><span class="line">abc&lt;comeau&gt; co; <span class="comment">// ok</span></span><br><span class="line">abc&lt;<span class="string">&quot;Comeau C++&quot;</span>&gt; co2; <span class="comment">// not ok</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">struct</span> <span class="title">qaz</span> &#123;</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[] = <span class="string">&quot;local&quot;</span>;</span><br><span class="line">    abc&lt;buf&gt; lb; <span class="comment">// not ok</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf2[] = <span class="string">&quot;local&quot;</span>;</span><br><span class="line">    abc&lt;buf2&gt; lb2; <span class="comment">// not ok</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">qwerty</span> &#123;</span>&#125;;</span><br><span class="line">    qaz&lt;qwerty&gt; dq; <span class="comment">// not ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Last but not least, <code>static</code> and unnamed namespaces are not the same because <code>static</code> is deficient as a name constrainer. Sure, a C programmer might use it for flag above, but what do you do when you want to layer or just encapsulate say a class, template, enum, or even another namespace? …for that you need namespaces. It might even be argued that you should wrap all your files in an unnamed namespace (all the file’s functions, classes, whatever) and then only pull out the parts other files should know about.</p>
<p>Draw your attention to that that none of the above is equal to this:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// x.cpp</span></span><br><span class="line"><span class="keyword">namespace</span> &#123; <span class="comment">// DDD</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(The point of showing <code>DDD</code> is that you really wouldn’t want to say it. I guess one could say that it is redundant, and really just brings all the above issues right back (as in this flavor, it’s not external). So, it’s only shown to make sure you see that none of the previous versions look like this :).</p>
<p>Note that namespaces containing <code>extern &quot;C&quot;</code> declarations are in some ways as if they were not declared in the namespace, so since an unnamed namespace is a namespace, this holds true for an unnamed namespace as well.</p>
<p>Note also that the above discussion does not apply to the other uses of static: static lifetime, static members or to static locals in a function.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://humphrycc.github.io/2021/04/12/Why-is-an-unnamed-namespace-used-instead-of-static/" data-id="ckno26i480003ceopegay4hv6" data-title="Why is an unnamed namespace used instead of static?" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/" rel="tag">c++</a></li></ul>

    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/c/" rel="tag">c++</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/c/" style="font-size: 10px;">c++</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/04/19/What-is-the-difference-between-a-concrete-class-and-an-abstract-class/">What is the difference between a concrete class and an abstract class?</a>
          </li>
        
          <li>
            <a href="/2021/04/12/What-s-this-extern-C-thing/">What&#39;s this extern &#34;C&#34; thing?</a>
          </li>
        
          <li>
            <a href="/2021/04/12/Why-is-an-unnamed-namespace-used-instead-of-static/">Why is an unnamed namespace used instead of static?</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>